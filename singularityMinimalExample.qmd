---
title: "Singularity with R"
author: "Carl Beuchel"
date: today
output:
  html_document:
  code_download: true
theme: spacelab #sandstone #flatfly #spacelab
highlight: pygments
toc: true  
toc-depth: 3
code-folding: show
number-sections: true
toc-float:
  smooth-scroll: true
editor: source
editor-options: 
  chunk-output-type: console
execute:
  eval: false
  echo: true
  warning: false
---


  
```{r setup}
#| include: false
#| echo: false
#| eval: false

# set a more recent R snapshot as source repo
r = getOption("repos") 
r["CRAN"] = "https://mran.microsoft.com/snapshot/2022-07-01"
options(repos = r)
rm(r)

# Update packages to that snapshot
update.packages(
  ask = FALSE, 
  checkBuilt = TRUE
  )

# Check unsuccessful updates packages
old.packages()

# Update V8
# Sys.setenv(DOWNLOAD_STATIC_LIBV8=1)
# Sys.getenv("DOWNLOAD_STATIC_LIBV8") # To get around V8 installation
# install.packages("V8")

# This needed a CXX17 definition in the Makevars
# install.packages("Boom") # still fails

# needed sudo R CMD rjavareconf 
# install.packages("rJava")

# install.packages("qs")
# install.packages("rstanarm")
```

## Setup

### Installation

Installation instructions for Singularity can be found in the [Singularity User
Guide](https://docs.sylabs.io/guides/3.10/user-guide/quick_start.html) and the
[Singularity Admin
Guide](https://docs.sylabs.io/guides/3.10/admin-guide/admin_quickstart.html).
Following the steps listed under `Quick Start`, it is relatively simple to build
Singularity from source.

### Add local binary to secure_path

When building singularity locally, the binary is found in the path `/usr/local/bin/`. To be able to build containers, they have to be run as root, but sometimes the `/usr/local/bin/` directory is not in `$PATH` for root, leading to a command not found error when running `sudo singularity`. Therefore it is necessary to append the directory to `secure_path` of the `/etc/sudoers` file. To do this, run the following command:

```{r}
#| eval: false

# edit the /etc/sudoers file with this command
sudo visudo
```

Search for a line that specifies the `secure_path`. It might look like this: `Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"`. Sometimes it might be commented out with a `#`. Now add the directory containing the singularity binary by adding it with a prepended `:` to the end of the line and remove the `#` if present, so that it looks similar to this. (NOTE: the directories listed on different machines might be in a different order or contain different directories altogether).

```{bash}
#| eval: false

# the line with ":/usr/local/bin/" appended
Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/bin/"
```

After saving this file, running `sudo singularity` should no longer produce a command not found error.


### Autocompletion

Create an auto-completion file to enable Tab-completion when typing singularity
commands in the bash command line.

```{bash}
#| eval: false

# Generate completion script
singularity completion bash > singularity

# Move it to the correct directory
sudo mv singularity /etc/bash_completion.d/singularity
```

Images (a `.sif`-file) can either be build locally using the `singularity buid`
command in conjunction with a configuration file (`.def`-file) or pulled from
Docker-Hub, an online resource that makes a large variety of images available
for users.

```{mermaid}
flowchart LR
  A(.def-File) --> B(.sif-Image)
  C[Docker Hub] --> B(.sif-Image)
  
```

The first example in the Singularity documentation is to run an image from
Docker hub, the infamous lolcow. The `--debug`-flag creates verbose output. The
`singularity run`-command does not download the image into the local working
directory, but into `.singularity/cache`.

```{bash}
#| eval: false

# display the content of the .singularity directory prior to running the command 
tree .singularity/cache

# Download and run the image from docker hub
singularity --debug run library://lolcow

# display the content of the .singularity directory after running the command 
tree .singularity/cache
```

The cache can be inspected using the `singularity cache list|clean` commands.
Images are named after their SHA256-hash, which can make managing many images in
cache confusing.

```{bash}
#| eval: false

# lists total number of containers in cache and the occupied space
singularity cache list

# deletes all files currently in the `.singularity/cache` folder, while retaining the directories.
singularity cache clean
```

### Pull a docker image from Docker Hub

A library with R-specific docker images can be found at
[Rocker](https://www.rocker-project.org/images/). Their website also includes an
introduction to [Singularity](https://www.rocker-project.org/use/singularity).
The following command pulls and converts an
[image](https://www.rocker-project.org/images/base/r-devel) from the docker hub,
a repository for pre-build docker images (`SIF` = Singularity Image File) from
Rocker. Specifications of each image can be found on the respective websites.
The advantage of this is to be able do create a singularity container without
specifying a .def file. The large amount of pre-configured images allows users
to quickly download containers that come with pre-installed applications for a
given task. This will download a file called `r-devel_latest.sif`, a singularity
container file into the current working directory.

```{bash}
#| eval: false

# Images can also be searched via this command. 
singularity search rocker

# Download the latest version of the r-devel Rocker Image from Docker Hub
singularity pull docker://rocker/r-devel

# Instead of downloading, the image can be build using the local singularity installation
singularity build r-devel-built.sif docker://rocker/r-devel
```

The dockerfile for this image can be retrieved from
[GitHub](https://raw.githubusercontent.com/rocker-org/r-devel/master/Dockerfile).
The following chunk downloads the respective dockerfile and deposits it in the
folder `resources`.

```{bash}
#| eval: false

# Download the docker file from github
wget https://raw.githubusercontent.com/rocker-org/r-devel/master/Dockerfile

# move it into a seperate folder
mkdir resources
mv Dockerfile resources/r_devel_dockerfile
```

The file can be inspected to see the configuration for the downloaded image.
Dockerfiles are however not compatible with singularity and cannot be used to
build the respective image (`.sif`-file). Singularity image build recipes are
called definition files and end on `.def`. Documentation is again available
through the [Sylabs Singularity
documentation](https://docs.sylabs.io/guides/3.10/user-guide/definition_files.html).

```{bash}
#| eval: false

cat ../resources/r_devel_dockerfile
```

### Run Image

Users can interact with containers in several ways: Run (`singularity run`) a
pre-specified command (in the `%runscript` section of the definition file), execute (`singularity exec`) and start a shell from
within the container (`singularity shell`). Using the `shell` command it can be seen that the content of the users' home directory (`/home/$USER`) can still be accessed when running the container. This is one of the mounted directories from the host machine. 


```{bash}
#| eval: false

# This command runs the command prespecified in the image. In the case of this container, it simply starts a new R-session.
singularity run r-devel_latest.sif

# This command runs a user-specified command, in this case a call to R that generates 100 normally distributed numbers.
singularity exec r-devel_latest.sif R --slave -e "rnorm(1e2)"

# This command opens a shell n the container environment. Notice how the prompt of the shell changes to something like `Singularity>`, but `ls` still returns the contents of your host machine (i. e. /home/YOUR_USER/ ).  This can also be run as root or non-root
singularity shell r-devel_latest.sif
```

### The definition file

From scratch, a SIF-file is built using a SingularityCE definition (`.def`)
file. This way, environment variables, libraries and files can be added to a
base-container. Specifications of the singularity definition file can again be
found in the [official
documentation](https://docs.sylabs.io/guides/3.10/user-guide/definition_files.html#definition-files).
It consists of several sections that define the build-instructions. The main parts are the Header and the Body.

*   Header: Specify the registry/library and the base container to be used for building the image
*   Body: Specify all installation instructions like libraries, environment variables, meta-data and files to be copied into the container etc.

The body contains several sections, each with specific tasks to be executed during the build process. A description of each section can be found [here](https://docs.sylabs.io/guides/3.10/user-guide/definition_files.html#sections). Our first test-SIF will contain the following sections.

*   `%post`: The section contains instructions to be executed at build time. It is used to install software to be used by the container. It can also be used to set environment variables that are set at build time. In this example, it is the date and time when the build command is run
*   `%environment`: Define environment variables to be set at runtime. In this example, it is the date and time when the container is run. 
*   `%runscript`: Define commands to be run when the container is executed via `singularity run`. In this case, print the date of container creation and start a R session.
*   `%labels`: Use to add meta data like author, version etc.
*   `%help`: Add information meta-data to be displayed when `singularity run-help` is run.

### Our first DEF and SIF

For an introduction, we can build our own `.sif`-image based on the light-weight docker image [Alpine](https://hub.docker.com/_/alpine). The header information about using alpine from docker hub can be found [here](https://docs.sylabs.io/guides/3.10/user-guide/appendix.html#build-docker-module). Then we will update the container library and install R using the alpine package manager `apk` and specify a runscript to start R when using `singularity run`. We will not set any environment variables and leave the field empty. The following chunk will create the `alpine_min_r.def` file in the current working directory.

```{bash}
#| eval: false

echo \
"BootStrap: docker
From: alpine:latest

%post
    apk update
    apk upgrade
    apk add R
    NOW=\`date\`
    echo \"export NOW=\\\"\${NOW}\\\"\" >> $SINGULARITY_ENVIRONMENT

%environment
    export AUTHOR=\"Carl\"

%runscript
    echo \"Container creation date: \$NOW\"
    echo \"Container run date: \`date\`\"
    echo \"Container creator: \$AUTHOR\"
    for i in 3 2 1; do echo \"Starting R in \$i...\"; sleep 1; done
    R
    
%labels
    Author: AG GenStat @ IMISE
    
%help
    This is a first test container. It starts a R session when executed." \
    >> alpine_min_r.def
```

Saving a file containing this chunk under e. g. `alpine_min_r.def`, it can be
now be build using by providing the name of the SIF file and the definition file
using `singularity build IMAGE_NAME.sif alpine_min_r.def`. This will create the
SIF in the current directory.


```{bash}
#| eval: false

# This needs to be run as root
singularity build alpine_min_r.sif alpine_min_r.def

```

We can now interact with with the newly-created container. 

### Investigate Image

Several commands can be used to inspect properties of a .sif file (singularity image file).

```{bash}
#| eval: false

# Displays some meta-data about the image, such as author, licence, build-date
singularity inspect alpine_min_r.sif

# Print the text supplied under %help in the DEF
singularity run-help alpine_min_r.sif
singularity inspect --helpfile alpine_min_r.sif

# List data objects in a SIF file
singularity sif list alpine_min_r.sif

# Displays info of image header with some meta-data about the container
singularity sif header alpine_min_r.sif

# Print information about the data objects
singularity sif info 1 r-devel_latest.sif
singularity sif info 2 r-devel_latest.sif
singularity sif info 3 r-devel_latest.sif
singularity sif info 4 r-devel_latest.sif
```

### Building mutable images

Instead of creating a binary image file, the container can also be build as a
browsable folder using the `--sandbox` option. Using this option, containers can
be modified as root user. SIFs cannot be changed, e. g. when using `singularity
shell` as root user. Using a sandbox can be useful to modify images without the
need to recurrently rebuild images. However, this should only be used for
development and testing, as any permanent changes to an image should be
specified in the image definition file. These sandbox can then be build into a
.sif using the `singularity build` command.

```{bash}
#| eval: false

# create new image in folder 
sudo singularity build --sandbox alpine_min_r_sandbox alpine_min_r.def

# change directories into the newly created sandbox and inspect it
cd alpine_min_r_sandbox
ls -hartl

# The folder acts as an image file and all singularity commands, e. g. shell, exec, and run will work without any need to modify commands.

# build the sandbox into a .sif
singularity build alpine_min_r.sif alpine_min_r_sandbox
```

### Environment variables TODO



### Files management

We want to use containers to contain, read and write files in order to properly
execute analysis modules. Creating files is straight-forward. Several
directories on the host machine are mounted when running a container. The
include the users’ home directory (i. e. `/home/YOUR_USER`) among others. These
are documented
[here](https://docs.sylabs.io/guides/latest/user-guide/bind_paths_and_mounts.html).
Directory mounts can be enabled and disabled for each container. It could for
example be useful to mount a directory containing data needed for a specific
analysis module that is saved outside of the users’ home directory. In the first
chunk, the working directory when running a container is printed to the console.

```{bash}
# Show the directory the container is executed from. Files will simply be saved
# here.
singularity exec alpine_min_r.sif pwd
```

With these commands, we will write a R data object (`.RData`) to our host
filesystem. This file is persistent and will exist after a container is closed.

```{bash}
# execute command from image. We will create a file in the local host directory
# that we can use later to learn how to handle files in SIFs
singularity exec alpine_min_r.sif R --slave -e "data(iris);save(iris,file=rDataFile.RData')"

# check for the newly created file
ls -hartl | grep -e RData
```

In addition to the standard mounted paths, additional directories can be mounted
using the `--bind` or `--mount` flags. The `--mount` flag expects specifications
in the format `type=bind,src=<source>,dst=<dest>`, with comma-delimited options.
The `source` is the directory on the host machine (the machine running the
container) and `dst` is the destination mount point on the container filesystem.
With the `ro` option, directories can be mounted as read-only, which is
especially useful for directories containing analysis data. With the following
command, the directory `/home/$USER` (i. e. the current user's home directory)
on the host will be mounted as read-only directory in the container. This is
demonstrated by trying to create (`touch`) an empty file in the target
directory. The system will refuse the operation.

```{bash}
singularity exec \
    --mount type=bind,source=/home/$USER,dst=/home/$USER,ro \
    my_container.sif touch /home/$USER/my_testfile
```

This can also be specified using the environment variable `$SINGULARITY_MOUNT`. Multiple mount points can be separated by newlines (`\\n`). The variable can be persistently set in the user's `.bashrc`. Other useful flags for that impact the default mounts are:

*   `--no-home`: Mounts the current working directory instead of `$HOME` when running the container. When 
*   `--containall` or `-C` binds a dummy home directory and not the host home. Files created in this directory are not persistent when leaving the container. 




--> Wie geht man damit um, dass nutzer auf bestimmte dateien zugriff bekommen und auf andere nicht. koennen die auf tmps selber sachen schreiben? wie werden die lese und schreibzugriffe geregelt?


### Using input files and handling output

Ich möchte `singularity run` mit inputfiles nutzen, z.b. singularity run calling_container.sif --> der dann die rohdaten von irgendwo fetcht


```{bash}
#| eval: false

alpine_min_r.sif 
rDataFile.RData
```


### Interacting with images


### The image filesystem

* singularity shell
* cd /.singularity.d
* cd /singularity

Information


[sdfsdfds](https://docs.sylabs.io/guides/3.10/user-guide/environment_and_metadata.html)
the def file can be found at `/.singularity`

"This example works because hostfile.txt exists in the user’s home directory. By default SingularityCE bind mounts /home/$USER, /tmp, and $PWD into your container at runtime."



### Use with worklfow DSL (Snakemake, Nextflow)

https://snakemake.readthedocs.io/en/stable/snakefiles/deployment.html


### User capabilities

```{bash}
#| eval: false

singularity capabilities

```


### TODO

*   do I need use FUSE mounts?
*   was ist mit runnern? oder besser gesagt, was sind runner genau?
*   Wie soll Datenzugriff funktionieren (Max fragen): initialer Zugriff ueber login node, speichern ueber lustre file system?
*   Einfach einen Ordner mit namen des nutzers im results folder der jeweiligen projekte erzeugen 
*   Motivation: Idiosynchratien von R und HPC streamlinen, Plattformübergreifende Analysem, Reproduzierbarkeit
*   Installation: Doku admin und user guide
*   SLURM, Nextflow
*   Rocker als Base-R container
*   OpenBLAS etc?
*   welche R version
*   wie können wir die containergröße gering halten?
*   Download über Rocker
*   eigene Defininition von .sif per .def
*   was ist der container?
*   wie baue ich einen container (base image, per .def file installation vornehmen)
*   https://jsta.github.io/r-docker-tutorial/ 
*   https://rviews.rstudio.com/2017/03/29/r-and-singularity/
*   custom .def file https://github.com/nickjer/singularity-r
*   Rocker Image overview: 
*   Rocker Singularity Intro: https://www.rocker-project.org/use/singularity
*   Singularity erlaubt unit test - Das brauchen wir! "singularity test"
*   create a "main.R" in the WD and run with "singularity run"
*   create image from .def with "sudo singularity create --size 4000 tensorflow.img && \ sudo singularity bootstrap tensorflow.img tensorflow.def"
*   Testing: Unit, Integration, Documentation, Regression, 
*   CI Pipeline: was wollen wir dabei haben?
