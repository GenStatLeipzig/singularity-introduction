---
title: "Singularity with R"
author: "Carl Beuchel"
date: today
output:
  html_document:
  code_download: true
theme: spacelab #sandstone #flatfly #spacelab
highlight: pygments
toc: true  
toc-depth: 3
code-folding: show
number-sections: true
toc-float:
  smooth-scroll: true
editor: source
editor-options: 
  chunk-output-type: console
execute:
  eval: false
  echo: true
  warning: false
---



```{r setup}
#| include: false
#| echo: false
#| eval: false

# set a more recent R snapshot as source repo
r = getOption("repos") 
r["CRAN"] = "https://mran.microsoft.com/snapshot/2022-07-01"
options(repos = r)
rm(r)

# Update packages to that snapshot
update.packages(
  ask = FALSE, 
  checkBuilt = TRUE
)

# Check unsuccessful updates packages
old.packages()

# Update V8
# Sys.setenv(DOWNLOAD_STATIC_LIBV8=1)
# Sys.getenv("DOWNLOAD_STATIC_LIBV8") # To get around V8 installation
# install.packages("V8")

# This needed a CXX17 definition in the Makevars
# install.packages("Boom") # still fails

# needed sudo R CMD rjavareconf 
# install.packages("rJava")

# install.packages("qs")
# install.packages("rstanarm")
```

## Setup

### Installation

Installation instructions for Singularity can be found in the [Singularity User
Guide](https://docs.sylabs.io/guides/3.10/user-guide/quick_start.html) and the
[Singularity Admin
Guide](https://docs.sylabs.io/guides/3.10/admin-guide/admin_quickstart.html).
Following the steps listed under `Quick Start`, it is relatively simple to build
Singularity from source.

### Add local binary to secure_path

When building singularity locally, the binary is found in the path `/usr/local/bin/`. To be able to build containers, they have to be run as root, but sometimes the `/usr/local/bin/` directory is not in `$PATH` for root, leading to a command not found error when running `sudo singularity`. Therefore it is necessary to append the directory to `secure_path` of the `/etc/sudoers` file. To do this, run the following command:

```{r}
#| eval: false

# edit the /etc/sudoers file with this command
sudo visudo
```

Search for a line that specifies the `secure_path`. It might look like this: `Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"`. Sometimes it might be commented out with a `#`. Now add the directory containing the singularity binary by adding it with a prepended `:` to the end of the line and remove the `#` if present, so that it looks similar to this. (NOTE: the directories listed on different machines might be in a different order or contain different directories altogether).

```{bash}
#| eval: false

# the line with ":/usr/local/bin/" appended
Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/bin/"
```

After saving this file, running `sudo singularity` should no longer produce a command not found error.


### Autocompletion

Create an auto-completion file to enable Tab-completion when typing singularity
commands in the bash command line.

```{bash}
#| eval: false

# Generate completion script
singularity completion bash > singularity

# Move it to the correct directory
sudo mv singularity /etc/bash_completion.d/singularity
```

Images (a `.sif`-file) can either be build locally using the `singularity buid`
command in conjunction with a configuration file (`.def`-file) or pulled from
Docker-Hub, an online resource that makes a large variety of images available
for users.

```{mermaid}
flowchart LR
A(.def-File) --> B(.sif-Image)
C[Docker Hub] --> B(.sif-Image)

```

The first example in the Singularity documentation is to run an image from
Docker hub, the infamous lolcow. The `--debug`-flag creates verbose output. The
`singularity run`-command does not download the image into the local working
directory, but into `.singularity/cache`.

```{bash}
#| eval: false

# display the content of the .singularity directory prior to running the command 
tree .singularity/cache

# Download and run the image from docker hub
singularity --debug run library://lolcow

# display the content of the .singularity directory after running the command 
tree .singularity/cache
```

The cache can be inspected using the `singularity cache list|clean` commands.
Images are named after their SHA256-hash, which can make managing many images in
cache confusing.

```{bash}
#| eval: false

# lists total number of containers in cache and the occupied space
singularity cache list

# deletes all files currently in the `.singularity/cache` folder, while retaining the directories.
singularity cache clean
```

## Usage

### Pull a docker image from Docker Hub

A library with R-specific docker images can be found at
[Rocker](https://www.rocker-project.org/images/). Their website also includes an
introduction to [Singularity](https://www.rocker-project.org/use/singularity).
The following command pulls and converts an
[image](https://www.rocker-project.org/images/base/r-devel) from the docker hub,
a repository for pre-build docker images (`SIF` = Singularity Image File) from
Rocker. Specifications of each image can be found on the respective websites.
The advantage of this is to be able do create a singularity container without
specifying a .def file. The large amount of pre-configured images allows users
to quickly download containers that come with pre-installed applications for a
given task. This will download a file called `r-devel_latest.sif`, a singularity
container file into the current working directory.

```{bash}
#| eval: false

# Images can also be searched via this command. 
singularity search rocker

# Download the latest version of the r-devel Rocker Image from Docker Hub
singularity pull docker://rocker/r-devel

# Instead of downloading, the image can be build using the local singularity installation
singularity build r-devel-built.sif docker://rocker/r-devel
```

The dockerfile for this image can be retrieved from
[GitHub](https://raw.githubusercontent.com/rocker-org/r-devel/master/Dockerfile).
The following chunk downloads the respective dockerfile and deposits it in the
folder `resources`.

```{bash}
#| eval: false

# Download the docker file from github
wget https://raw.githubusercontent.com/rocker-org/r-devel/master/Dockerfile

# move it into a seperate folder
mkdir resources
mv Dockerfile resources/r_devel_dockerfile
```

The file can be inspected to see the configuration for the downloaded image.
Dockerfiles are however not compatible with singularity and cannot be used to
build the respective image (`.sif`-file). Singularity image build recipes are
called definition files and end on `.def`. Documentation is again available
through the [Sylabs Singularity
documentation](https://docs.sylabs.io/guides/3.10/user-guide/definition_files.html).

```{bash}
#| eval: false

cat ../resources/r_devel_dockerfile
```

### Run Image

Users can interact with containers in several ways: Run (`singularity run`) a
pre-specified command (in the `%runscript` section of the definition file), execute (`singularity exec`) and start a shell from
within the container (`singularity shell`). Using the `shell` command it can be seen that the content of the users' home directory (`/home/$USER`) can still be accessed when running the container. This is one of the mounted directories from the host machine. 


```{bash}
#| eval: false

# This command runs the command prespecified in the image. In the case of this container, it simply starts a new R-session.
singularity run r-devel_latest.sif

# This command runs a user-specified command, in this case a call to R that generates 100 normally distributed numbers.
singularity exec r-devel_latest.sif R --slave -e "rnorm(1e2)"

# This command opens a shell n the container environment. Notice how the prompt of the shell changes to something like `Singularity>`, but `ls` still returns the contents of your host machine (i. e. /home/YOUR_USER/ ).  This can also be run as root or non-root
singularity shell r-devel_latest.sif
```

### The definition file

From scratch, a SIF-file is built using a SingularityCE definition (`.def`)
file. This way, environment variables, libraries and files can be added to a
base-container. Specifications of the singularity definition file can again be
found in the [official
documentation](https://docs.sylabs.io/guides/3.10/user-guide/definition_files.html#definition-files).
It consists of several sections that define the build-instructions. The main parts are the Header and the Body.

*   Header: Specify the registry/library and the base container to be used for building the image
*   Body: Specify all installation instructions like libraries, environment variables, meta-data and files to be copied into the container etc.

The body contains several sections, each with specific tasks to be executed during the build process. A description of each section can be found [here](https://docs.sylabs.io/guides/3.10/user-guide/definition_files.html#sections). Our first test-SIF will contain the following sections.

*   `%post`: The section contains instructions to be executed at build time. It is used to install software to be used by the container. It can also be used to set environment variables that are set at build time. In this example, it is the date and time when the build command is run. The command is saved in the file `/.singularity.d/env/91-environment.sh` and sourced when starting the container. 
*   `%environment`: Define environment variables to be set at runtime. In this example, it is the date and time when the container is run. 
*   `%runscript`: Define commands to be run when the container is executed via `singularity run`. In this case, print the date of container creation and start a R session.
*   `%labels`: Use to add meta data like author, version etc.
*   `%help`: Add information meta-data to be displayed when `singularity run-help` is run.

### Our first DEF and SIF

For an introduction, we can build our own `.sif`-image based on the light-weight docker image [Alpine](https://hub.docker.com/_/alpine). The header information about using alpine from docker hub can be found [here](https://docs.sylabs.io/guides/3.10/user-guide/appendix.html#build-docker-module). Then we will update the container library and install R using the alpine package manager `apk` and specify a runscript to start R when using `singularity run`. We will not set any environment variables and leave the field empty. The following chunk will create the `alpine_min_r.def` file in the current working directory.

```{bash}
#| eval: false

echo \
"BootStrap: docker
From: alpine:latest

%post
apk update
apk upgrade
apk add R
NOW=\`date\`
echo \"export NOW=\\\"\${NOW}\\\"\" >> \$SINGULARITY_ENVIRONMENT

%environment
export AUTHOR=\"Carl\"

%runscript
echo \"Container creation date: \$NOW\"
echo \"Container run date: \`date\`\"
echo \"Container creator: \$AUTHOR\"
for i in 3 2 1; do echo \"Starting R in \$i...\"; sleep 1; done
R

%labels
Author: AG GenStat @ IMISE

%help
This is a first test container. It starts a R session when executed." \
>> alpine_min_r.def
```

Saving a file containing this chunk under e. g. `alpine_min_r.def`, it can be
now be build using by providing the name of the SIF file and the definition file
using `singularity build IMAGE_NAME.sif alpine_min_r.def`. This will create the
SIF in the current directory.


```{bash}
#| eval: false

# This needs to be run as root
singularity build alpine_min_r.sif alpine_min_r.def

```

We can now interact with with the newly-created container. 

### Investigate Image

Several commands can be used to inspect properties of a .sif file (singularity image file).

```{bash}
#| eval: false

# Displays some meta-data about the image, such as author, licence, build-date
singularity inspect alpine_min_r.sif

# Print the text supplied under %help in the DEF
singularity run-help alpine_min_r.sif
singularity inspect --helpfile alpine_min_r.sif

# List data objects in a SIF file
singularity sif list alpine_min_r.sif

# Displays info of image header with some meta-data about the container
singularity sif header alpine_min_r.sif

# Print information about the data objects
singularity sif info 1 r-devel_latest.sif
singularity sif info 2 r-devel_latest.sif
singularity sif info 3 r-devel_latest.sif
singularity sif info 4 r-devel_latest.sif
```

### Building mutable images

A SIF is by default read-only, so a built image cannot be changed. Instead of
creating a binary image file, the container can also be build as a browsable
folder using the `--sandbox` option. Using this option, containers can be
modified as root user. SIFs cannot be changed, e. g. when using `singularity
shell` as root user. Using a sandbox can be useful to modify images without the
need to recurrently rebuild images. However, this should only be used for
development and testing, as any permanent changes to an image should be
specified in the image definition file. These sandbox can then be build into a
.sif using the `singularity build` command.

```{bash}
#| eval: false

# create new image in folder 
sudo singularity build --sandbox alpine_min_r_sandbox alpine_min_r.def

# change directories into the newly created sandbox and inspect it
cd alpine_min_r_sandbox
ls -hartl

# The folder acts as an image file and all singularity commands, e. g. shell, exec, and run will work without any need to modify commands.

# build the sandbox into a .sif
singularity build alpine_min_r.sif alpine_min_r_sandbox
```

### Environment variables
Haste die ganze Woche Home Office? Viel passiert da ja sicher eh nicht am ersten Tag nach Festival oder
2min

Setting and manipulating environment variables in a container is a convenient
feature for creating settings. They can be set in the DEF, as well as when
starting a container. Useful flags are:

*   `--env` flag: Set variables when calling `exec/run/shell` in the form of `singularity exec --env VARIABLE1=VALUE1, VARIABLE2=VALUE2 alpine_min_r.sif`
*   `--env-file` flag: Set variables from a text file in the form `VARIABLE=VALUE`

Running the container with the flag `--cleanenv` will retain none but the
essential variables in the container environment. The default variables are
documented
[here](https://docs.sylabs.io/guides/3.10/user-guide/environment_and_metadata.html).
Environment variables set in a container can be quickly searched using the `env`
command in conjunction with `grep`. For example, searching all
singularity-specific variables, i. e. those prefixed with `SINGULARITY_` can be
accomplished using this command:

```{bash}
singularity exec alpine_min_r.sif env | grep ^SINGULARITY
```

This also lists `SINGULARITY_ENVIRONMENT`, specifying the variables set in the
`%post` section of the DIF.

A specific feature is the ability to manipulate `$PATH`, the variable specifying
where the system looks for executable applications. This is important when a
program is installed as a non-root user and the application binary is created in
a folder not in `$PATH`. Ways to specify non-default paths are documented
[here](https://docs.sylabs.io/guides/3.10/user-guide/environment_and_metadata.html#manipulating-path).

### Files management and mounting of directories

We want to use containers to contain, read and write files in order to properly
execute analysis modules. Creating files is straight-forward. Several
directories on the host machine are mounted when running a container. The
include the users’ home directory (i. e. `/home/YOUR_USER`) among others. These
are documented
[here](https://docs.sylabs.io/guides/latest/user-guide/bind_paths_and_mounts.html).
Directory mounts can be enabled and disabled for each container. It could for
example be useful to mount a directory containing data needed for a specific
analysis module that is saved outside of the users’ home directory. In the first
chunk, the working directory when running a container is printed to the console.

```{bash}
# Show the directory the container is executed from. Files will simply be saved
# here.
singularity exec alpine_min_r.sif pwd
```

With these commands, we will write a R data object (`.RData`) to our host
filesystem. This file is persistent and will exist after a container is closed.

```{bash}
# execute command from image. We will create a file in the local host directory
# that we can use later to learn how to handle files in SIFs
singularity exec alpine_min_r.sif R --slave -e "data(iris);save(iris,file='rDataFile.RData')"

# check for the newly created file
ls -hartl | grep -e RData
```

In addition to the standard mounted paths, additional directories can be mounted
using the `--bind` or `--mount` flags. The `--mount` flag expects specifications
in the format `type=bind,src=<source>,dst=<dest>`, with comma-delimited options.
The `source` is the directory on the host machine (the machine running the
container) and `dst` is the destination mount point on the container filesystem.
With the `ro` option, directories can be mounted as read-only, which is
especially useful for directories containing analysis data. With the following
command, the directory `/home/$USER` (i. e. the current user's home directory)
on the host will be mounted as read-only directory in the container. This is
demonstrated by trying to create (`touch`) an empty file in the target
directory. The system will refuse the operation.

```{bash}
singularity exec \
--mount type=bind,source=/home/$USER,dst=/home/$USER,ro \
my_container.sif touch /home/$USER/my_testfile
```

This can also be specified using the environment variable `$SINGULARITY_MOUNT`.
Multiple mount points can be separated by newlines (`\\n`). The variable can be
persistently set in the user's `.bashrc`. Other useful flags for that impact the
default mounts are:

*   `--no-home`: Mounts the current working directory instead of `$HOME` when running the container. When 
*   `--containall` or `-C` binds a dummy home directory and not the host home. Files created in this directory are not persistent when leaving the container. 

### Using input files and handling output

We want to add analysis scripts as R-scripts or snakemake files to containers to
use them as isolated analysis modules. Therefore, in addition to programs and
libraries necessary for the analysis, the analysis scripts need to be saved in
the container. Files to be added to an image can be specified in the definition
file in the `$files` section. The details are documented
[here](https://docs.sylabs.io/guides/latest/user-guide/definition_files.html#files).
For complicated analyses, the input needs to be highly standardized and tested
and output needs to be saved in a directory that is accessible for the user but
should still be read-only. Re-using the `alpine_min_r.def` from above, the
following DEF contains an additional section `%files`, that instructs
singularity to package the file `rDataFile.RData` into the image file. The
instructions are given in the format `<source> [<destination>]`. The source file
is mandatory, the destination optional, since the path of the source file will
be mirrored if no destination is given. `rDataFile.RData`, currently in the
working directory, will be copied to `/data` in the container's root directory.
Additionally, a small`main.R` script using the copied file will be created under
the `/scripts/` directory that will be executed when running the container that
loads the saved `rDataFile.RData`. It is also possible to copy multiple files
using a pattern-matching syntax documented
[here](https://docs.sylabs.io/guides/latest/user-guide/definition_files.html#copying-multiple-files-with-patterns).

```{bash}
# This creates the analysis script in the current directory
echo \
"# Load the data file from within the container from the directory specified in the %files section
load(\"/data/rDataFile.RData\")

# Create some output
summary(iris)

# Do some kind of computation on the data and return output
print(paste0(\"The mean sepal length is:\", round(mean(iris\$Sepal.Length), 2)))

# Finish up and provide info about computing environment
print(\"Finishing analysis....\")
sessionInfo()" \
> main.R

# This created the DEF
echo \
"BootStrap: docker
From: alpine:latest

%post
apk update
apk upgrade
apk add R
NOW=\`date\`
echo \"export NOW=\\\"\${NOW}\\\"\" >> \$SINGULARITY_ENVIRONMENT

%files
rDataFile.RData /data/
main.R  /scripts/

%environment
export AUTHOR=\"Carl\"

%runscript
echo \"Container creation date: \$NOW\"
echo \"Container run date: \`date\`\"
echo \"Container creator: \$AUTHOR\"
Rscript --verbose /scripts/main.R

%labels
Author: AG GenStat @ IMISE

%help
This is a first test container. It runs a small R script when executed." \
> alpine_min_r.def
```

Building and running the container (using the `-C` flag to not mount the home
directory) will execute the `main.R` script and produce the desired output.

```{bash}
# build the recipe
singularity build alpine_min_r.sif alpine_min_r.def

# without mounting anything
singularity run -C alpine_min_r.def
```

## A first minimum example analysis module

In this section, we will create a container using the features explored above.
The container should contain a simple analysis script, read files from a mounted
read-only directory and save results, including a log of the analysis output to
a user-specific folder on the host filesystem.

```{bash}
# create the directories to mimic the (imaginated) host machine our
# container will run on
mkdir singularity_host/data
mkdir singularity_host/results
mkdir singularity_host/scripts

# move the input data (which might be a huge file) to a central directory on
# the host machine and not into the container
mv rDataFile.RData singularity_host/data/Data_01.RData

# this results in a clean host directory structure including folders for the 
# data, the analysis scripts and the results
tree singularity_host
```

We can use bash commands to prepare our system for this new container.
Specifically, we must create a unique and writable result folder and create the
environment variable specifying the mount point for the `data` and `results`
folders.

```{bash}
# create the name for the result folder based on the username and some
#randomness to avoid collisions
RAND_PART=`head -c 500 /dev/urandom | tr -dc 'A-Z0-9' | head -c 5`
FOLDER_NAME=${USER}_${RAND_PART}

# make the FOLDER_NAME variable accessible for the shell 
export FOLDER_NAME

# since randomness is involved, save the results folder name in a file in the user's home
echo $FOLDER_NAME > /home/$USER/.env

# The folder will be the mount point for the user's results
mkdir /home/$USER/TutorialContainers/singularity_host/results/$FOLDER_NAME

# specify the mount points as environment variable for when running the container
export SINGULARITY_BIND="singularity_host/data:/mnt/data:ro,singularity_host/results/'$FOLDER_NAME':/mnt/results"

# this should work but doesn't
# export SINGULARITY_MOUNT=$'type=bind,src=singularity_host/data,dst=/mnt/data,ro\ntype=bind,src=singularity_host/results/'$FOLDER_NAME',dst=/mnt/results'
```

**NOTE:** Setting the environment variable `$SINGULARITY_MOUNT` presents some
problems. Multiple mounts should be separated by a newline `"\\n"`, but it still
failed for this example. Therefore, the variable `$SINGULARITY_BIND` was used
that demands a different syntax in the form `<source>:<destination>:<option>`
and different mounts can be separated by a comma.

When running this command as a script, it is important not to run the script
using `./myscript.sh`, because this will start a new shell within our executing
shell and the environment variables will not be set. Instead, using the
dot-notation or `source` will execute the commands in the current shell. Now the
container DEF and the analysis can be specified. In this DEF, we also install
additional libraries in the container in the `%post%` section, namely the
`data.table` package. Note that additional system libraries (`apk add zlib
zlib-dev pkgconfig R-dev make openmp`) need to be installed in order for
`data.table` to install successfully.

```{bash}
echo \
"BootStrap: docker
From: alpine:latest

%post
apk update
apk upgrade
apk add zlib zlib-dev pkgconfig R R-dev make openmp
NOW=\`date\`
echo \"export NOW=\\\"\${NOW}\\\"\" >> \$SINGULARITY_ENVIRONMENT

# Install necessary libraries
R --slave -e 'install.packages(\"data.table\", repos=\"https://cloud.r-project.org/\")'

%files
singularity_host/scripts/Analysis_01.R  /scripts/main.R

%runscript
echo \"Container creation date: \$NOW\"
echo \"Container run date: \`date\`\"
echo \"Container creator: \$USER\"
Rscript --vanilla --verbose /scripts/main.R > /mnt/results/Analysis_01.Rout

%labels
Author: AG GenStat @ IMISE

%help
This is a minimal example container. It utilizes mounts and runs a small R script when executed." \
> alpine_analysis_01.def
```

The analysis script (`Analysis_01.R` on the host, simply `main.R` in the
container) should read the mounted file, do some computations and save some
results that can be accessed once the container finished the analysis. Starting the scripts using `Rscript` is the successor of `R CMD BATCH` and also accepts common flags:

* `--vanilla`: Combine --no-save, --no-restore, --no-site-file --no-init-file and --no-environ
* `--verbose`: Print information on progress (can be piped into file)
* `--slave`: Run as quietly as possible (when a subprocess and no output is required)

```{bash}
echo "\
library(data.table)

# This data is loaded from the mounted directory on the host machine
load(\"/mnt/data/Data_01.RData\")

# use the loaded library
setDT(iris)

# Create some output
summary(iris)

# create a summary table
res <- iris[, .(mean_sepal_length = mean(Sepal.Length),
                max_sepal_width = max(Sepal.Width),
                min_petal_length = min(Petal.Length),
                total_petal_width = sum(Petal.Width)
                ), by = Species]

# save the result file to the results folder
fwrite(x = res,file = \"/mnt/results/Results_01.csv\", sep = \",\")

# Finish up and provide info about computing environment
print(\"Finishing analysis....\")
sessionInfo()"\
>   singularity_host/scripts/Analysis_01.R

# check the structure of our host directory
tree singularity_host
```

Now the DEF as well as the analysis are ready and the container can be built.

```{bash}
# create the image (needs to be run as root using `sudo`)
singularity build alpine_analysis_01.sif alpine_analysis_01.def

# run the image 
singularity run alpine_analysis_01.sif

# check whether output was produced
tree sigularity_host

# Two files were created, first a log of the script (a html report would be nicer)
cat singularity_host/results/Analysis_01.Rout

# The second file is a csv with the results from the analysis
cat singularity_host/results/Results_01.csv
```

## Future additions

### The image filesystem TODO

* singularity shell
* cd /.singularity.d
* cd /singularity
* the def file can be found at `/.singularity`
* "This example works because hostfile.txt exists in the user’s home directory. By default SingularityCE bind mounts `/home/$USER`, `/tmp`, and `$PWD` into your container at runtime."
* Additionally, we can supply additional arguments to the  argument to run... (digits to round )
+ `args <- commandArgs(trailingOnly = TRUE); rnorm(n=as.numeric(args[1]), mean=as.numeric(args[2]))`
+ might be useful to pipe arguments from singularity run/exec to Rscript...

### Use with Snakemake TODO

Installation

* Install Miniconda in userspace, which is default (reduces python bloat)
  + `update conda conda update -n base -c defaults conda`
  + Install mamba: `conda install -n base -c conda-forge mamba`
* Install Snakemake (base)
  + `conda activate base` (Switch to environment?)
  + `mamba create -c conda-forge -c bioconda -n snakemake snakemake` (install snakemakle)
  + `conda activate snakemake` (reverse is `conda deactivate`)
* Install Snakemake (minimal)
  + `conda activate base`
  + `mamba create -c bioconda -c conda-forge -n snakemake snakemake-minimal`
* Use mamba
  + `mamba init`
  + `mamba activate snakemake`
  + `mamba deactivate`
* Don't start (base) automatically: `conda config --set auto_activate_base false` (creates file `~/.condarc` containing `auto_activate_base: false`) --> just set this file manually
  + more elegant way: `export CONDA_AUTO_ACTIVATE_BASE=false`
* Snakemake has built-in compatibility with [Singularity](https://snakemake.readthedocs.io/en/latest/snakefiles/deployment.html): 
* Introduction to environments in python [here](https://towardsdatascience.com/a-guide-to-conda-environments-bc6180fc533)

### Tests TODO

* section `%test`

### TODO

*   Rscript input via `CommandArgs()`
*   `R --slave -e "source()"` would also work
*   creating a quarto doc with html reports is probably a good idea `quarto render ... --to html`
*   `Rscript --verbose myScript.R  > myScript.Rout` minimal output file...
*   date tag
*   restrictive umask!
*   how to create/manage workspaces?
*   do I need use FUSE mounts?
*   was ist mit runnern? oder besser gesagt, was sind runner genau?
*   Wie soll Datenzugriff funktionieren (Max fragen): initialer Zugriff ueber login node, speichern ueber lustre file system?
*   Einfach einen Ordner mit namen des nutzers im results folder der jeweiligen projekte erzeugen 
*   Motivation: Idiosynchratien von R und HPC streamlinen, Plattformübergreifende Analysem, Reproduzierbarkeit
*   Installation: Doku admin und user guide
*   SLURM, Nextflow
*   Rocker als Base-R container
*   OpenBLAS etc?
*   welche R version
*   wie können wir die containergröße gering halten?
*   https://jsta.github.io/r-docker-tutorial/ 
*   https://rviews.rstudio.com/2017/03/29/r-and-singularity/
*   custom .def file https://github.com/nickjer/singularity-r
*   https://njstem.wordpress.com/2018/08/02/r-script-seurat-with-a-singularity-container-using-slurm/
*   Rocker Singularity Intro: https://www.rocker-project.org/use/singularity
*   Singularity erlaubt unit test - Das brauchen wir! "singularity test"
*   create image from .def with "sudo singularity create --size 4000 tensorflow.img && \ sudo singularity bootstrap tensorflow.img tensorflow.def"
*   Testing: Unit, Integration, Documentation, Regression, 
*   CI Pipeline: was wollen wir dabei haben?
